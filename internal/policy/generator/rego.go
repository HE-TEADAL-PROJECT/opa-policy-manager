// Procude a rego representation of a policy structure for an API service.
//
// All the rego rules generated assume that a set of variables will be defined in the same Reg module, which are:
//   - `user`: must be a string containing the user ID
//   - `roles`: must be a rego set of strings containing the roles of the user
//   - `path`: must be a string containing the path of the request (just endpoint path, not the full URL)
//   - `method`: must be an all caps string containing the HTTP method of the request (e.g., "GET", "POST")
package generator

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	. "dspn-regogenerator/internal/policy"
)

type ServiceData struct{}

const (
	globalPolicyName  = "global_policy"
	RequestPolicyName = "allow_request"
)

// Convert a basic policy object to its Rego representation
//
// This function handles various policy types, including UserPolicy, RolePolicy, CallPolicy, StoragePolicy, and TimelinessPolicy.
// It supports both single policies (even with pointers) and slices/array of policies, recursively generating Rego rules for each item.
// It can also handle PolicyClause objects, which may contain multiple policies.
//
// Referes to package documentation for the expected variables that must be defined in the same Rego module
func GeneratePolicyRego(serviceData ServiceData, policy any) (string, error) {
	var rego string
	var err error

	t := reflect.TypeOf(policy)
	if t.Kind() == reflect.Array || t.Kind() == reflect.Slice {
		for i := 0; i < reflect.ValueOf(policy).Len(); i++ {
			item := reflect.ValueOf(policy).Index(i).Interface()
			itemRego, err := GeneratePolicyRego(serviceData, item)
			if err != nil {
				return "", fmt.Errorf("error generating Rego for item %d of type %T: %w", i, item, err)
			}
			if itemRego != "" {
				if rego != "" {
					rego += "\n"
				}
				rego += itemRego
			}
		}
		return rego, nil
	} else if t.Kind() == reflect.Pointer {
		if reflect.ValueOf(policy).IsNil() {
			return "", nil // Return empty string for nil pointers
		}
		return GeneratePolicyRego(serviceData, reflect.ValueOf(policy).Elem().Interface())
	} else if t.Kind() != reflect.Struct {
		return "", fmt.Errorf("unsupported policy type: %T", policy)
	}

	switch p := policy.(type) {
	case UserPolicy, RolePolicy, CallPolicy, StoragePolicy, TimelinessPolicy:
		rego, err = generateBasicPolicyRego(serviceData, p)
	case PolicyClause:
		rego, err = generatePolicyClauseRego(serviceData, p)
	default:
		err = fmt.Errorf("unsupported policy type: %T", p)
	}
	if err != nil {
		return "", fmt.Errorf("error generating Rego for policy %T: %w", policy, err)
	}

	return rego, nil
}

// Generate the rego code for a service's policies.
//
// This function generates a string containing Rego rules that represent the policies for a service. The main rule is `allow_request`, which determines if a request is allowed based on the defined policies.
//
// Refers to the package documentation for the expected variables that must be defined in the same Rego module.
func GenerateServiceRego(serviceData ServiceData, policies GeneralPolicies) (string, error) {
	// rules generated by this function will be in the format:
	rules := make([]string, 0)

	// Generate the clauses for the global policy
	globalClauses := make([]string, 0, len(policies.Policies))
	for i, clause := range policies.Policies {
		rego, err := generatePolicyClauseRego(serviceData, clause)
		if err != nil {
			return "", fmt.Errorf("error generating Rego for policy clause %d: %w",
				i, err)
		}
		if rego != "" {
			globalClauses = append(globalClauses, rego)
		}
	}

	if len(globalClauses) == 0 { // If there are no global policies, we create an always true rule
		rule := globalPolicyName + " := true\n"
		rules = append(rules, rule)
	} else { // If there are global policies, we create the global policy rule
		defaultRule := "default " + globalPolicyName + " := false\n"
		rules = append(rules, defaultRule)

		for i, clause := range globalClauses {
			rule := createRegoRule(globalPolicyName, clause)
			if rule != "" {
				rules = append(rules, rule)
			} else {
				return "", fmt.Errorf("error generating Rego for global policy clause %d: empty rule", i)
			}
		}
	}

	// Generate specialized policies for each path
	pathsClauses := make([]string, 0, len(policies.SpecializedPaths))
	pathSet := make([]string, 0, len(policies.SpecializedPaths))
	for path, policies := range policies.SpecializedPaths {
		pathClauses, err := generatePoliciesForPath(serviceData, path, policies)
		if err != nil {
			return "", fmt.Errorf("error generating Rego for path %s: %w", path, err)
		}
		if len(pathClauses) > 0 {
			pathSet = append(pathSet, path)
			pathsClauses = append(pathsClauses, pathClauses...)
		}
	}

	if len(pathsClauses) == 0 {
		allowRule := RequestPolicyName + " := " + globalPolicyName + "\n"
		rules = append(rules, allowRule)
	} else {
		pathsClauses = append(pathsClauses, "not path in "+arrayToRegoSet(pathSet))
		rules = append(rules, "default "+RequestPolicyName+" := false\n")
		for i, clause := range pathsClauses {
			rule := createRegoRule(RequestPolicyName, globalPolicyName+"\n"+clause)
			if rule != "" {
				rules = append(rules, rule)
			} else {
				return "", fmt.Errorf("error generating Rego for path policy clause %d: empty rule", i)
			}
		}
	}

	return strings.Join(rules, "\n"), nil
}

// generates Rego rules for a basic policy type (UserPolicy, RolePolicy, etc.)
func generateBasicPolicyRego(_ ServiceData, policy any) (string, error) {
	var rego string
	var err error

	switch p := policy.(type) {
	case UserPolicy:
		if len(p.Value) == 0 {
			return "", fmt.Errorf("policy value cannot be empty for UserPolicy")
		}
		userSet := arrayToRegoSet(p.Value)
		switch p.Operator {
		case "":
			fallthrough
		case OperatorAnd:
			rego = fmt.Sprintf("{user} == %s", userSet)
		case OperatorOr:
			rego = fmt.Sprintf("user in %s", userSet)
		default:
			err = fmt.Errorf("unsupported operator for UserPolicy: %s", p.Operator)
		}
	case RolePolicy:
		if len(p.Value) == 0 {
			return "", fmt.Errorf("policy value cannot be empty for RolePolicy")
		}
		roleSet := arrayToRegoSet(p.Value)
		switch p.Operator {
		case "":
			fallthrough
		case OperatorAnd:
			rego = fmt.Sprintf("roles == %s", string(roleSet))
		case OperatorOr:
			rego = fmt.Sprintf("roles & %s != set()", string(roleSet))
		default:
			err = fmt.Errorf("unsupported operator for RolePolicy: %s", p.Operator)
		}
	case StoragePolicy, TimelinessPolicy, CallPolicy:
		// TODO: Implement Rego generation for StoragePolicy, TimelinessPolicy, and CallPolicy
		break
	default:
		err = fmt.Errorf("unsupported policy type: %T", p)
	}

	return rego, err
}

// generates Rego rules for a PolicyClause, which may contain multiple policies.
func generatePolicyClauseRego(serviceData ServiceData, clause PolicyClause) (string, error) {
	var conditions []string
	if clause.UserPolicy != nil {
		rego, err := generateBasicPolicyRego(serviceData, *clause.UserPolicy)
		if err != nil {
			return "", fmt.Errorf("error generating UserPolicy Rego: %w", err)
		}
		if rego != "" {
			conditions = append(conditions, rego)
		}
	}
	if clause.RolePolicy != nil {
		rego, err := generateBasicPolicyRego(serviceData, *clause.RolePolicy)
		if err != nil {
			return "", fmt.Errorf("error generating RolePolicy Rego: %w", err)
		}
		if rego != "" {
			conditions = append(conditions, rego)
		}
	}
	if clause.StorageLocationPolicy != nil {
		rego, err := generateBasicPolicyRego(serviceData, *clause.StorageLocationPolicy)
		if err != nil {
			return "", fmt.Errorf("error generating StorageLocationPolicy Rego: %w", err)
		}
		if rego != "" {
			conditions = append(conditions, rego)
		}
	}
	if clause.CallPolicy != nil {
		rego, err := generateBasicPolicyRego(serviceData, *clause.CallPolicy)
		if err != nil {
			return "", fmt.Errorf("error generating CallPolicy Rego: %w", err)
		}
		if rego != "" {
			conditions = append(conditions, rego)
		}
	}
	if clause.TimelinessPolicy != nil {
		rego, err := generateBasicPolicyRego(serviceData, *clause.TimelinessPolicy)
		if err != nil {
			return "", fmt.Errorf("error generating TimelinessPolicy Rego: %w", err)
		}
		if rego != "" {
			conditions = append(conditions, rego)
		}
	}
	if len(conditions) == 0 {
		return "", nil // No conditions to generate
	}
	return strings.Join(conditions, "\n"), nil
}

func generatePoliciesForPath(serviceData ServiceData, path string, policies PathPolicies) ([]string, error) {
	// Extract the code for the path policies
	clausesRego := make([]string, 0, len(policies.Policies))
	for i, clause := range policies.Policies {
		rego, err := generatePolicyClauseRego(serviceData, clause)
		if err != nil {
			return nil, fmt.Errorf("error generating Rego for policy clause %d: %w", i, err)
		}
		if rego != "" {
			rego = "path == \"" + path + "\"\n" + rego // Add path condition
			clausesRego = append(clausesRego, rego)
		}
	}
	// Generate all possible alternative blocks for each method
	methodsClauses := make([]string, 0, len(policies.SpecializedMethods))
	methodSet := make([]string, 0, len(policies.SpecializedMethods))
	for method, policies := range policies.SpecializedMethods {
		methodBlocks, err := generatePoliciesForMethod(serviceData, method, policies)
		if err != nil {
			return nil, fmt.Errorf("error generating Rego for method %s: %w", method, err)
		}
		if len(methodBlocks) > 0 {
			methodsClauses = append(methodsClauses, methodBlocks...)
			methodSet = append(methodSet, strings.ToUpper(method))
		}
	}
	// If there are no specialized methods, use the default method
	if len(methodsClauses) == 0 {
		return clausesRego, nil // No specialized methods, return only path policies
	} else {
		// Add a clause for the default method (not specified in specialized methods)
		methodsClauses = append(methodsClauses, "not method in "+arrayToRegoSet(methodSet))
	}
	// Combine path policies with specialized methods
	blocks := make([]string, 0, len(methodsClauses)*len(clausesRego)+len(clausesRego))
	if len(clausesRego) == 0 {
		for _, methodClause := range methodsClauses {
			// Combine path and method clauses
			blocks = append(blocks, "path == \""+path+"\"\n"+methodClause)
		}
	} else {
		for _, clause := range clausesRego {
			for _, methodClause := range methodsClauses {
				// Combine path and method clauses
				blocks = append(blocks, clause+"\n"+methodClause)
			}
		}
	}
	return blocks, nil
}

func generatePoliciesForMethod(serviceData ServiceData, method string, policies PathMethodPolicies) ([]string, error) {
	blocks := make([]string, 0, len(policies.Policies)+1)
	if len(policies.Policies) == 0 {
		return blocks, nil // No policies to generate
	}
	methodRego := "method == \"" + strings.ToUpper(method) + "\"\n"
	for i, clause := range policies.Policies {
		rego, err := generatePolicyClauseRego(serviceData, clause)
		if err != nil {
			return nil, fmt.Errorf("error generating Rego for policy clause %d: %w", i, err)
		}
		if rego != "" {
			blocks = append(blocks, methodRego+rego)
		}
	}
	return blocks, nil
}

// convert an array to its Rego set representation.
func arrayToRegoSet(arr []string) string {
	if len(arr) == 0 {
		return "set()"
	}
	jsonArray, err := json.Marshal(arr)
	if err != nil {
		panic(err)
	}
	// Substitute square brackets with curly braces for Rego set syntax
	jsonArray[0] = '{'
	jsonArray[len(jsonArray)-1] = '}'
	return string(jsonArray)
}

func indentRegoBlock(block string) string {
	lines := strings.Split(block, "\n")
	for i, line := range lines {
		lines[i] = "    " + line
	}
	return strings.Join(lines, "\n")
}

// createRegoRule creates a Rego rule with the given name and body with format "name if {\nbody\n}\n".
func createRegoRule(name, body string) string {
	if body == "" {
		return ""
	}
	return fmt.Sprintf("%s if {\n%s\n}\n", name, indentRegoBlock(body))
}
